---
layout: post
title: Why Senior Engineers Talk About Trade-offs More Than Code
date: 2026-02-14
---

# Why Senior Engineers Talk About Trade-offs More Than Code

Recently, while working on a backend module in a Spring Boot service deployed on AWS, something struck me.

The discussion wasn’t about writing the feature, it was about architecture.
Should we extract this module into a separate microservice? Or keep it inside the existing monolith?

A few years ago, I wouldn’t have hesitated. Microservices would’ve sounded like the obvious answer. Independent deployments. Isolated scaling. Clean service boundaries.

But over the years, experience has reshaped my thinking.

I’ve seen what happens after that decision is made.
- One service becomes five.
- One deployment pipeline becomes many.
- Local setup gets heavier.
- Cross-service communication introduces latency and retry logic.
- Data consistency needs to be handled more carefully.

None of this is wrong. In the right context, it’s absolutely worth it. 
But it’s not free.

That’s when I started seeing architecture decisions less as upgrades and more as commitments.

Earlier in my career, I had come to a similar line of thinking with design patterns and abstractions.
I remember building highly flexible modules with strategy patterns, extension points, configurable workflows. It looked clean. It looked “architected.”
But months later, onboarding new developers was harder. Debugging required jumping across multiple layers. 
I learnt that flexibility had a cost. Every abstraction became something someone had to mentally unpack later.

Over time, my thinking shifted.

Now I like to pause and ask :
- Do we truly need independent scaling, or would vertical scaling be enough?
- Is the team mature enough operationally to handle distributed systems?
- Are we solving a real requirement, or engineering for a hypothetical future?
- Is the additional flexibility truly driven by business needs?
And that 'learning to pause' has been one of the biggest shifts in my journey.

It is no longer about writing more code or adopting more services. It’s also been about understanding the trade-offs.

Monolith vs microservices.
Simplicity vs flexibility.
Speed vs maintainability.

Every decision optimises something and sacrifices something else.
The best systems I’ve worked on weren’t the most complex. They were the most intentional.
And that’s a lesson I’m still refining with every project.
